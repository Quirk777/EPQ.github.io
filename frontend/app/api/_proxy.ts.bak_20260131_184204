import { NextRequest, NextResponse } from "next/server";

const BACKEND_URL = process.env.BACKEND_URL || "http://127.0.0.1:8001";

function joinUrl(base: string, path: string) {
  const b = base.replace(/\/+$/, "");
  const p = (path || "").startsWith("/") ? path : /;
  return ${b};
}

/**
 * proxyRaw:
 * - Forwards request to FastAPI and returns the response as-is (status/body/headers)
 * - DOES NOT throw on non-2xx (so 401 stays 401, not Next 500)
 */
export async function proxyRaw(req: NextRequest, path: string, init?: RequestInit) {
  const url = joinUrl(BACKEND_URL, path);
  const fullUrl = req.nextUrl.search ? ${url} : url;

  const headers = new Headers(req.headers);
  headers.delete("host");

  const method = req.method.toUpperCase();
  let body: BodyInit | undefined = undefined;

  if (method !== "GET" && method !== "HEAD") {
    // Keep JSON bodies as raw text to avoid parse issues
    const ct = headers.get("content-type") || "";
    if (ct.includes("application/json")) {
      body = await req.text();
      if (!headers.get("content-type")) headers.set("content-type", "application/json");
    } else {
      body = await req.arrayBuffer();
    }
  }

  const res = await fetch(fullUrl, {
    method,
    headers,
    body,
    redirect: "manual",
    ...init,
  });

  const outHeaders = new Headers(res.headers);
  // Avoid hop-by-hop headers that can break Next
  outHeaders.delete("content-encoding");
  outHeaders.delete("transfer-encoding");
  outHeaders.delete("connection");

  const data = await res.arrayBuffer();
  return new NextResponse(data, { status: res.status, headers: outHeaders });
}

/**
 * proxyJson:
 * Alias to proxyRaw (kept for existing imports)
 */
export async function proxyJson(req: NextRequest, path: string, init?: RequestInit) {
  return proxyRaw(req, path, init);
}

/**
 * proxy:
 * Backwards-compat export so existing routes importing { proxy } keep working.
 */
export const proxy = proxyRaw;