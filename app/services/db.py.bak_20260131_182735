import sqlite3
from pathlib import Path
import uuid
import json
from typing import Optional, Dict, Any, List

DB_PATH = (Path(__file__).resolve().parents[2] / "epq.db").resolve()

def _connect():
    # single source of truth for sqlite DB path
    return sqlite3.connect(str(DB_PATH))


def get_connection():
    conn = sqlite3.connect(str(DB_PATH))
    conn.row_factory = sqlite3.Row
    return conn


def init_db():
    conn = get_connection()
    c = conn.cursor()

    c.execute("""
    CREATE TABLE IF NOT EXISTS employers (
        employer_id TEXT PRIMARY KEY,
        company_name TEXT NOT NULL,
        email TEXT,
        subscription_status TEXT NOT NULL
    )
    """)

    c.execute("""
    CREATE TABLE IF NOT EXISTS assessments (
        assessment_id TEXT PRIMARY KEY,
        employer_id TEXT NOT NULL,
        environment TEXT NOT NULL,
        max_questions INTEGER NOT NULL,
        status TEXT NOT NULL,
        pdf_filename TEXT,
        created_utc TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (employer_id) REFERENCES employers(employer_id)
    )
    """)

    # store applicant responses (audit trail)
    c.execute("""
    CREATE TABLE IF NOT EXISTS applicant_responses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        assessment_id TEXT NOT NULL,
        responses_json TEXT NOT NULL,
        created_utc TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (assessment_id) REFERENCES assessments(assessment_id)
    )
    """)

    # per-applicant submissions (the real unit you care about)
    c.execute("""
    CREATE TABLE IF NOT EXISTS applicants (
        candidate_id TEXT PRIMARY KEY,
        assessment_id TEXT NOT NULL,
        applicant_name TEXT NOT NULL,
        applicant_email TEXT NOT NULL,
        responses_json TEXT NOT NULL,
        score_json TEXT,                  -- optional: store computed result
        pdf_status TEXT NOT NULL,         -- pending | success | failed
        pdf_filename TEXT,
        pdf_error TEXT,
        submitted_utc TEXT DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (assessment_id) REFERENCES assessments(assessment_id)
    )
    """)

    conn.commit()
    conn.close()


# ------------------------
# Employers
# ------------------------
def create_employer(company_name: str, email: str) -> str:
    employer_id = str(uuid.uuid4())
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "INSERT INTO employers (employer_id, company_name, email, subscription_status) VALUES (?, ?, ?, ?)",
        (employer_id, company_name, email, "inactive"),
    )
    conn.commit()
    conn.close()
    return employer_id


def get_employer(employer_id: str) -> Optional[Dict[str, Any]]:
    conn = get_connection()
    c = conn.cursor()
    c.execute("SELECT * FROM employers WHERE employer_id=?", (employer_id,))
    row = c.fetchone()
    conn.close()
    return dict(row) if row else None


def set_employer_active(employer_id: str):
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "UPDATE employers SET subscription_status=? WHERE employer_id=?",
        ("active", employer_id),
    )
    conn.commit()
    conn.close()


# ------------------------
# Assessments
# ------------------------
def create_assessment(employer_id: str, environment: str, max_questions: int) -> str:
    assessment_id = str(uuid.uuid4())
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        """INSERT INTO assessments
           (assessment_id, employer_id, environment, max_questions, status, pdf_filename)
           VALUES (?, ?, ?, ?, ?, ?)""",
        (assessment_id, employer_id, environment, int(max_questions), "pending", None),
    )
    conn.commit()
    conn.close()
    return assessment_id


def get_assessment(assessment_id: str) -> Optional[Dict[str, Any]]:
    conn = get_connection()
    c = conn.cursor()
    c.execute("SELECT * FROM assessments WHERE assessment_id=?", (assessment_id,))
    row = c.fetchone()
    conn.close()
    return dict(row) if row else None


def set_assessment_pdf(assessment_id: str, pdf_filename: str):
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "UPDATE assessments SET status=?, pdf_filename=? WHERE assessment_id=?",
        ("completed", pdf_filename, assessment_id),
    )
    conn.commit()
    conn.close()


def list_assessments_for_employer(employer_id: str) -> List[Dict[str, Any]]:
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "SELECT assessment_id, environment, status, pdf_filename, max_questions FROM assessments WHERE employer_id=? ORDER BY created_utc DESC",
        (employer_id,),
    )
    rows = c.fetchall()
    conn.close()
    return [dict(r) for r in rows]

def list_applicant_submissions_for_employer(employer_id: str) -> List[Dict[str, Any]]:
    """
    Dashboard feed for an employer:
    Returns applicant submissions across ALL assessments owned by employer_id.

    Fields returned:
      candidate_id, assessment_id, applicant_name, applicant_email,
      submitted_utc, pdf_status, pdf_filename, pdf_error,
      environment, max_questions
    """
    conn = get_connection()
    c = conn.cursor()

    c.execute(
        """
        SELECT
            ap.candidate_id,
            ap.assessment_id,
            ap.applicant_name,
            ap.applicant_email,
            ap.submitted_utc,
            ap.pdf_status,
            ap.pdf_filename,
            ap.pdf_error,
            a.environment,
            a.max_questions
        FROM applicants ap
        JOIN assessments a ON a.assessment_id = ap.assessment_id
        WHERE a.employer_id = ?
        ORDER BY ap.submitted_utc DESC
        """,
        (employer_id,),
    )

    rows = c.fetchall()
    conn.close()
    return [dict(r) for r in rows]

# ------------------------
# Applicant responses
# ------------------------
def store_applicant_responses(assessment_id: str, responses: Dict[str, int]):
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "INSERT INTO applicant_responses (assessment_id, responses_json) VALUES (?, ?)",
        (assessment_id, json.dumps(responses)),
    )
    conn.commit()
    conn.close()

def create_applicant_submission(
    assessment_id: str,
    applicant_name: str,
    applicant_email: str,
    responses: Dict[str, int],
    candidate_id: str,
    score: Optional[Dict[str, Any]] = None,
):
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        """INSERT INTO applicants
           (candidate_id, assessment_id, applicant_name, applicant_email, responses_json, score_json, pdf_status, pdf_filename, pdf_error)
           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)""",
        (
            candidate_id,
            assessment_id,
            applicant_name,
            applicant_email,
            json.dumps(responses),
            json.dumps(score) if score is not None else None,
            "pending",
            None,
            None,
        ),
    )
    conn.commit()
    conn.close()

def applicant_exists_for_assessment(assessment_id: str, email: str) -> bool:
    with sqlite3.connect(str(DB_PATH)) as con:
        cur = con.cursor()
        row = cur.execute(
            "SELECT 1 FROM applicants WHERE assessment_id=? AND lower(applicant_email)=lower(?) LIMIT 1",
            (assessment_id, email),
        ).fetchone()
        return row is not None

def set_applicant_pdf_success(candidate_id: str, pdf_filename: str):
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "UPDATE applicants SET pdf_status=?, pdf_filename=?, pdf_error=? WHERE candidate_id=?",
        ("success", pdf_filename, None, candidate_id),
    )
    conn.commit()
    conn.close()


def set_applicant_pdf_failed(candidate_id: str, error_message: str):
    # keep error short-ish so sqlite doesn't balloon
    msg = (error_message or "")[:2000]
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        "UPDATE applicants SET pdf_status=?, pdf_error=? WHERE candidate_id=?",
        ("failed", msg, candidate_id),
    )
    conn.commit()
    conn.close()


def list_applicants_for_assessment(assessment_id: str) -> List[Dict[str, Any]]:
    conn = get_connection()
    c = conn.cursor()
    c.execute(
        """SELECT candidate_id, applicant_name, applicant_email, submitted_utc, pdf_status, pdf_filename, pdf_error
           FROM applicants
           WHERE assessment_id=?
           ORDER BY submitted_utc DESC""",
        (assessment_id,),
    )
    rows = c.fetchall()
    conn.close()
    return [dict(r) for r in rows]

def get_applicant_by_candidate_id(candidate_id: str) -> dict | None:
    with sqlite3.connect(str(DB_PATH)) as con:
        con.row_factory = sqlite3.Row
        cur = con.cursor()
        row = cur.execute(
            "SELECT * FROM applicants WHERE candidate_id = ? LIMIT 1",
            (candidate_id,),
        ).fetchone()
        return dict(row) if row else None